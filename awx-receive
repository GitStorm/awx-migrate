#!/usr/bin/env python

import base64
import hashlib
import pickle
import json
import os
import sys
import copy

from cryptography.fernet import Fernet, InvalidToken
from cryptography.hazmat.backends import default_backend

from tower_cli.cli.transfer.receive import Receiver

import psycopg2
import psycopg2.extras


AWX_SECRET_KEY = os.getenv('AWX_SECRET_KEY', 'awxsecret')
AWX_DBNAME = os.getenv('AWX_DBNAME', 'awx')
AWX_DBUSER = os.getenv('AWX_DBUSER', 'awx')
AWX_DBPASSWORD = os.getenv('AWX_DBPASSWORD', 'awxpass')
AWX_DBHOST = os.getenv('AWX_DBHOST', 'localhost')
AWX_DBPORT = os.getenv('AWX_DBPORT', '5432')
AWX_DATA_CACHE = os.getenv('AWX_DATA_CACHE', 'awx-data.pickle')


class Fernet256(Fernet):

    '''Not techincally Fernet, but uses the base of the Fernet spec and
    uses AES-256-CBC instead of AES-128-CBC. All other functionality
    remain identical.
    '''

    def __init__(self, key, backend=None):
        if backend is None:
            backend = default_backend()

        key = base64.urlsafe_b64decode(key)
        if len(key) != 64:
            raise ValueError(
                "Fernet key must be 64 url-safe base64-encoded bytes."
            )

        self._signing_key = key[:32]
        self._encryption_key = key[32:]
        self._backend = backend


def get_encryption_key(field_name, pk=None):
    '''
    Generate key for encrypted password based on field name,
    ``settings.SECRET_KEY``, and instance pk (if available).

    :param pk: (optional) the primary key of the model object;
               can be omitted in situations where you're encrypting a setting
               that is not database-persistent (like a read-only setting)
    '''
    h = hashlib.sha512()
    h.update(AWX_SECRET_KEY)
    if pk is not None:
        h.update(str(pk))
    h.update(field_name)
    return base64.urlsafe_b64encode(h.digest())


def decrypt_value(encryption_key, value):
    raw_data = value[len('$encrypted$'):]
    # If the encrypted string contains a UTF8 marker, discard it
    utf8 = raw_data.startswith('UTF8$')
    if utf8:
        raw_data = raw_data[len('UTF8$'):]
    algo, b64data = raw_data.split('$', 1)
    if algo != 'AESCBC':
        raise ValueError('unsupported algorithm: %s' % algo)
    encrypted = base64.b64decode(b64data)
    f = Fernet256(encryption_key)
    value = f.decrypt(encrypted)
    # If the encrypted string contained a UTF8 marker, decode the data
    if utf8:
        value = value.decode('utf-8')
    return value


def awx_get_data():

    if os.path.isfile(AWX_DATA_CACHE) and os.access(AWX_DATA_CACHE, os.W_OK):
        awx_data = pickle.load(open(AWX_DATA_CACHE, "rb"))
    else:
        awx_data = _awx_get_data()
        _awx_dump_data(awx_data)

    return awx_data


def _awx_get_data():

    receiver = Receiver()
    data = receiver.export_assets(all=True, asset_input=None)

    return data


def _awx_dump_data(data):

    pickle.dump(data, open(AWX_DATA_CACHE, "wb"))


def awx_getdb_creds():

    # oc port-forward postgresql-5-phl5d 5432:5432
    try:
        conn = psycopg2.connect(dbname=AWX_DBNAME, user=AWX_DBUSER,
                                password=AWX_DBPASSWORD, host=AWX_DBHOST,
                                port=AWX_DBPORT)
    except Exception as e:
        sys.stderr.write("I am unable to connect to the database:\n\n%s\n" % e)
        sys.exit(1)

    cur = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)
    cur.execute("""SELECT id, name, organization_id, inputs,
                 credential_type_id FROM main_credential""")
    table = cur.fetchall()

    # TODO what if multiple credentials with same name?
    awx_creds = {}
    for row in table:
        name = row[1]
        if name not in awx_creds:
            cred = dict(pk=row[0],
                        name=row[1],
                        organization_id=row[2],
                        inputs=row[3],
                        credential_type_id=row[4],
                        )
            row2dict = {name: cred}
        else:
            _err = "duplicate cred found: %s", name
            sys.stderr.write(_err + '\n')
            sys.exit(1)
        awx_creds.update(row2dict)

    return awx_creds


def decrypt_inputs(awx_creds):

    for key, value in awx_creds.items():
        pk = value['pk']
        inputs = value['inputs']
        name = value['name']
        for k, v in inputs.items():
            if v.startswith('$encrypted$'):
                encrypted = v
                encryption_key = get_encryption_key(k, pk if pk else None)
                try:
                    decrypted = decrypt_value(encryption_key, encrypted)
                except InvalidToken:
                    _err = ("Wrong encryption key for "
                            "input field {0} for "
                            "credential {1}").format(k, name)
                    sys.stderr.write(_err + '\n')
                    continue
                value['inputs'][k] = decrypted
        awx_creds[key] = value

    return awx_creds


def update_data_with_creds(awx_data, awx_creds):

    index = 0
    for item in awx_data:
        if item["asset_type"] == "credential":
            item2 = copy.deepcopy(item)
            if item['name'] in awx_creds:
                item2["inputs"] = awx_creds[item['name']]['inputs']
                awx_data.remove(item)
                awx_data.insert(index, item2)
            else:
                _err = ("Credential not found in the database for "
                        "credential {0}").format(item['name'])
                sys.stderr.write(_err + '\n')
        index += 1

    return awx_data


def main():

    awx_creds = decrypt_inputs(awx_getdb_creds())
    awx_data = awx_get_data()
    update_data_with_creds(awx_data, awx_creds)

    sys.stdout.write(json.dumps(awx_data))


if __name__ == "__main__":
    main()
